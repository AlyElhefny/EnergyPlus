# using forked version of SWIG at https://github.com/macumber/swig/tree/openstudio_swig_3_0_12
if(UNIX)
  # We patch it up with a version of pcre we provide to avoid having to have the requirement locally
  ExternalProject_Add(SWIG
    URL http://openstudio-resources.s3.amazonaws.com/dependencies/swig-3.0.12.tar.gz
    URL_MD5 a7d384966974ed79455a455b517ad83d
    PATCH_COMMAND cp ${CMAKE_SOURCE_DIR}/../dependencies/pcre-8.31.tar.bz2 ${CMAKE_BINARY_DIR}/SWIG-prefix/src/SWIG && cd ${CMAKE_BINARY_DIR}/SWIG-prefix/src/SWIG && ./Tools/pcre-build.sh
    CONFIGURE_COMMAND ./autogen.sh && ./configure --prefix=${CMAKE_BINARY_DIR}/SWIG-prefix/src/SWIG-install
    BUILD_COMMAND ${MAKE}
    INSTALL_COMMAND ${MAKE} install
    BUILD_IN_SOURCE 1
  )
  set(SWIG_EXECUTABLE ${CMAKE_BINARY_DIR}/SWIG-prefix/src/SWIG-install/bin/swig)
else()
  # SWIG requires MinGW to compile on windows, so we just copy in the prebuilt binary
  set(SWIG_ZIP "swigwin-3.0.12.zip")
  set(SWIG_DIR "swigwin-3.0.12")
  set(SWIG_EXPECTED_HASH "8ee412d1278ba3cac22e58f26a842918")
  if(EXISTS "${CMAKE_BINARY_DIR}/${SWIG_ZIP}")
    file(MD5 "${CMAKE_BINARY_DIR}/${SWIG_ZIP}" SWIG_HASH)
  endif()
  if(NOT EXISTS "${CMAKE_BINARY_DIR}/${SWIG_ZIP}" OR NOT EXISTS "${CMAKE_BINARY_DIR}/${SWIG_DIR}" OR NOT "${SWIG_HASH}" MATCHES "${SWIG_EXPECTED_HASH}")
    message(STATUS "Downloading SWIG)")
    file(DOWNLOAD "http://openstudio-resources.s3.amazonaws.com/dependencies/${SWIG_ZIP}" "${CMAKE_BINARY_DIR}/${SWIG_ZIP}" TIMEOUT 120 INACTIVITY_TIMEOUT 120 SHOW_PROGRESS EXPECTED_MD5 ${SWIG_EXPECTED_HASH})
    execute_process(COMMAND ${CMAKE_COMMAND} -E remove_directory "${CMAKE_BINARY_DIR}/${SWIG_DIR}")
    execute_process(COMMAND ${CMAKE_COMMAND} -E tar xfz "${CMAKE_BINARY_DIR}/${SWIG_ZIP}" WORKING_DIRECTORY "${CMAKE_BINARY_DIR}")
  endif()

  set(SWIG_EXECUTABLE ${CMAKE_BINARY_DIR}/${SWIG_DIR}/swig.exe)
endif()

# need python
# TODO: add support for 3.x
find_package(PythonInterp 3.0 REQUIRED)
find_package(PythonLibs 3.0 REQUIRED)
include_directories(SYSTEM ${PYTHON_INCLUDE_DIRS})
set(ALL_PYTHON_BINDINGS "") # global list of python bindings
set(ALL_PYTHON_BINDING_DEPENDS "") # global list of library dependencies of the generated wrapper cxx files
set(ALL_PYTHON_WRAPPER_FILES "") # global list of generated wrapper cxx files
set(ALL_PYTHON_WRAPPER_TARGETS "") # global list targets that build generated wrapper cxx files

# add a swig target
# KEY_I_FILE should include path, see src/utilities/CMakeLists.txt.
macro(MAKE_SWIG_TARGET NAME SIMPLENAME KEY_I_FILE I_FILES PARENT_TARGET PARENT_SWIG_TARGETS)
  set(DEPENDS "${PARENT_TARGET}")
  set(SWIG_DEFINES "")
  set(SWIG_COMMON "")

  ##
  ## Begin collection of requirements to reduce SWIG regenerations
  ## and fix parallel build issues
  ##

  # Get all of the source files for the parent target this SWIG library is wrapping
  get_target_property(target_files ${PARENT_TARGET} SOURCES)

  foreach(f ${target_files})
    # Get the extension of the source file
    get_source_file_property(p "${f}" LOCATION)
    get_filename_component(extension "${p}" EXT)

    # If it's a header file ("*.h*") add it to the list of headers
    if("${extension}" MATCHES "\\.h.*")
      if("${extension}" MATCHES "\\..xx" OR "${p}" MATCHES "ui_.*\\.h")
        list(APPEND GeneratedHeaders "${p}")
      else()
        list(APPEND RequiredHeaders "${p}")
      endif()
    endif()
  endforeach()

  # Now, append all of the .i* files provided to the macro to the
  # list of required headers.
  foreach(i ${I_FILES})
    get_source_file_property(p "${i}" LOCATION)
    get_filename_component(extension "${p}" EXT)
    if("${extension}" MATCHES "\\..xx")
      list(APPEND GeneratedHeaders "${p}")
    else()
      list(APPEND RequiredHeaders "${p}")
    endif()
  endforeach()

  # RequiredHeaders now represents all of the headers and .i files that all
  # of the SWIG targets generated by this macro call rely on.
  # And GeneratedHeaders contains all .ixx and .hxx files needed to make
  # these SWIG targets

  set(ParentSWIGWrappers "")
  # Now we loop through all of the parent swig targets and collect the requirements from them
  foreach(p ${PARENT_SWIG_TARGETS})
    get_target_property(target_files "ruby_${p}" SOURCES)

    if("${target_files}" STREQUAL "target_files-NOTFOUND")
      message(FATAL_ERROR "Unable to locate sources for ruby_${p}, there is probably an error in the build order for ${NAME} in the top level CMakeLists.txt or you have not properly specified the dependencies in MAKE_SWIG_TARGET for ${NAME}")
    endif()

    #message(STATUS "${target_files}")
    # This is the real data collection
    list(APPEND ParentSWIGWrappers ${${p}_SWIG_Depends})
  endforeach()


  # Reduce the size of the RequiredHeaders list
  list(REMOVE_DUPLICATES RequiredHeaders)

  if(GeneratedHeaders)
    list(REMOVE_DUPLICATES GeneratedHeaders)
  endif()

  # Here we now have:
  #  RequiredHeaders: flat list of all of the headers from the library we are currently wrapping and
  #                   all of the libraries that it depends on

  # Export the required headers variable up to the next level so that further SWIG targets can look it up
  #set(exportname "${NAME}RequiredHeaders")

  # Oh, and also export it to this level, for peers, like the Utilities breakouts and the Model breakouts
  set(${exportname} "${RequiredHeaders}")
  set(${exportname} "${RequiredHeaders}" PARENT_SCOPE)

  if(NOT TARGET ${PARENT_TARGET}_GeneratedHeaders)
    # Add a command to generate the generated headers discovered at this point.
    add_custom_command(
      OUTPUT "${CMAKE_BINARY_DIR}/${PARENT_TARGET}_HeadersGenerated_done.stamp"
      COMMAND ${CMAKE_COMMAND} -E touch "${CMAKE_BINARY_DIR}/${PARENT_TARGET}_HeadersGenerated_done.stamp"
      DEPENDS ${GeneratedHeaders}
    )

    # And a target that calls the above command
    add_custom_target(${PARENT_TARGET}_GeneratedHeaders
      SOURCES "${CMAKE_BINARY_DIR}/${PARENT_TARGET}_HeadersGenerated_done.stamp"
    )

    # Now we say that our PARENT_TARGET depends on this new GeneratedHeaders
    # target. This is where the magic happens. By making both the parent
    # and this *_swig.cxx files below rely on this new target we force all
    # of the generated files to be generated before either the
    # PARENT_TARGET is built or the cxx files are generated. This solves the problems with
    # parallel builds trying to generate the same file multiple times while still
    # allowing files to compile in parallel
    add_dependencies(${PARENT_TARGET} ${PARENT_TARGET}_GeneratedHeaders)
  endif()

 
  # Python bindings

  set(swig_target "python_${NAME}")

  # utilities goes into OpenStudio. directly, everything else is nested
  # DLM: SWIG generates a file ${MODULE}.py for each module, however we have several libraries in the same module
  # so these clobber each other.  Making these unique, e.g. MODULE = TOLOWER "${NAME}", generates unique .py wrappers
  # but the module names are unknown and the bindings fail to load.  I think we need to write our own custom OpenStudio.py
  # wrapper that imports all of the libraries/python wrappers into the appropriate modules.
  # http://docs.python.org/2/tutorial/modules.html
  # http://docs.python.org/2/library/imp.html

  string(TOLOWER "${NAME}" LOWER_NAME)
  set(MODULE ${LOWER_NAME})

  set(SWIG_WRAPPER "python_${NAME}_wrap.cxx")
  set(SWIG_WRAPPER_FULL_PATH "${CMAKE_CURRENT_BINARY_DIR}/${SWIG_WRAPPER}")

  set(PYTHON_GENERATED_SRC_DIR "${CMAKE_BINARY_DIR}/python_wrapper/generated_sources/")
  file(MAKE_DIRECTORY ${PYTHON_GENERATED_SRC_DIR})

  set(PYTHON_GENERATED_SRC "${PYTHON_GENERATED_SRC_DIR}/${LOWER_NAME}.py")

  set(PYTHON_AUTODOC "")
  if(BUILD_DOCUMENTATION)
    set(PYTHON_AUTODOC -features autodoc=1)
  endif()


  # Add the -py3 flag if the version used is Python 3
  set(SWIG_PYTHON_3_FLAG "")
  if (PYTHON_VERSION_MAJOR) 
    if (PYTHON_VERSION_MAJOR EQUAL 3)
      set(SWIG_PYTHON_3_FLAG -py3)
      message(STATUS "${MODULE} - Building SWIG Bindings for Python 3")
    else()
      message(STATUS "${MODULE} - Building SWIG Bindings for Python 2")
    endif()
  else()
    message(STATUS "${MODULE} - Couldnt determine version of Python - Building SWIG Bindings for Python 2")
  endif()

  add_custom_command(
    OUTPUT "${SWIG_WRAPPER_FULL_PATH}"
    COMMAND "${SWIG_EXECUTABLE}"
            "-python" ${SWIG_PYTHON_3_FLAG} "-c++" ${PYTHON_AUTODOC} 
            -outdir ${PYTHON_GENERATED_SRC_DIR} "-I${CMAKE_SOURCE_DIR}/src" "-I${CMAKE_BINARY_DIR}/src"
            -module "${MODULE}"
            -o "${SWIG_WRAPPER_FULL_PATH}"
            "${SWIG_DEFINES}" ${SWIG_COMMON} ${KEY_I_FILE}
    DEPENDS ${this_depends}
  )

  
  set_source_files_properties(${SWIG_WRAPPER_FULL_PATH} PROPERTIES GENERATED TRUE)
  set_source_files_properties(${PYTHON_GENERATED_SRC} PROPERTIES GENERATED TRUE)

  #add_custom_target(${SWIG_TARGET}
  #  DEPENDS ${SWIG_WRAPPER_FULL_PATH}
  #)

  add_library(
    ${swig_target}
    MODULE
    ${SWIG_WRAPPER}
  )

  install(FILES "${PYTHON_GENERATED_SRC}" DESTINATION Python COMPONENT "Python")
  install(TARGETS ${swig_target} DESTINATION Python COMPONENT "Python")

  set_target_properties(${swig_target} PROPERTIES OUTPUT_NAME _${LOWER_NAME})
  set_target_properties(${swig_target} PROPERTIES PREFIX "")
  set_target_properties(${swig_target} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/")
  set_target_properties(${swig_target} PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/")
  set_target_properties(${swig_target} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/")
  if(MSVC)
    set_target_properties(${swig_target} PROPERTIES COMPILE_FLAGS "/bigobj /wd4996 /wd4005") ## /wd4996 suppresses deprecated warning, /wd4005 suppresses macro redefinition warning
    set_target_properties(${swig_target} PROPERTIES SUFFIX ".pyd")
  elseif(UNIX)
    if(APPLE AND NOT CMAKE_COMPILER_IS_GNUCXX)
      set_target_properties(${swig_target} PROPERTIES COMPILE_FLAGS "-Wno-dynamic-class-memaccess -Wno-deprecated-declarations")
    else()
      set_target_properties(${swig_target} PROPERTIES COMPILE_FLAGS "-Wno-deprecated-declarations")
    endif()
  endif()
  
  if(MSVC)
    target_link_libraries(${swig_target} ${PARENT_TARGET})
    target_link_libraries( ${swig_target} debug ${PYTHON_DEBUG_LIBRARY})
    target_link_libraries( ${swig_target} optimized ${PYTHON_LIBRARY})
  else()
    target_link_libraries(${swig_target} ${PARENT_TARGET} ${PYTHON_LIBRARY})
  endif()

  add_dependencies(${swig_target} ${PARENT_TARGET})
  add_dependencies(${swig_target} ${DEPENDS})

  # add this target to a "global" variable so python tests can require these
  list(APPEND ALL_PYTHON_BINDINGS "${swig_target}")
  set(ALL_PYTHON_BINDINGS "${ALL_PYTHON_BINDINGS}" PARENT_SCOPE)

  list(APPEND ALL_PYTHON_BINDING_DEPENDS "${PARENT_TARGET}")
  set(ALL_PYTHON_BINDING_DEPENDS "${ALL_PYTHON_BINDING_DEPENDS}" PARENT_SCOPE)

  list(APPEND ALL_PYTHON_WRAPPER_FILES "${SWIG_WRAPPER_FULL_PATH}")
  set(ALL_PYTHON_WRAPPER_FILES "${ALL_PYTHON_WRAPPER_FILES}" PARENT_SCOPE)

  list(APPEND ALL_PYTHON_WRAPPER_TARGETS "${SWIG_TARGET}")
  set(ALL_PYTHON_WRAPPER_TARGETS "${ALL_PYTHON_WRAPPER_TARGETS}" PARENT_SCOPE)

endmacro()